
### **✨ 项目架构蓝图 v1.3 (概念版)**

### **第一部分：整体架构设计 (High-Level Architecture Design)**

#### **1. 设计理念与原则 (Design Philosophy & Principles)**

* **核心哲学：权威监听服务器 (Authoritative Listen Server)**
    * **阐述：** 一名玩家设备兼作客户端和服务器（Host），其他玩家作为纯客户端（Client）连接。
    * **为什么适合：** 完全符合“本地联机”需求，极大降低开发和部署的复杂性。

* **关键架构原则：**
    * **服务器绝对权威 (Server Authority):** 客户端的操作是“请求”，服务器(Host)处理后将结果“同步”给所有人。
    * **KISS (Keep It Simple, Stupid):** 专注于核心对战体验，不引入非必要的复杂性。
    * **网络接口抽象化 (Abstracted Network Interface):** 封装网络通信，为未来可能的专用服务器迁移做准备。

#### **2. 核心数据模型 (Core Data Model)**

* **`CharacterData` (角色数据资源):**
    * **类型:** Godot `Resource` (`.tres` 文件)。
    * **职责:** 定义一个角色的所有**静态属性**。这是一个纯粹的数据容器。
    * **核心字段:** `character_name` (字符串), `max_health` (浮点数), `move_speed` (浮点数), `jump_force` (浮点数), `skills` (一个`SkillData`资源的数组)。

* **`SkillData` (技能数据资源):**
    * **类型:** Godot `Resource` (`.tres` 文件)。
    * **职责:** 定义一个技能的所有**静态属性**。
    * **核心字段:** `skill_name` (字符串), `damage` (浮点数), `cooldown` (浮点数), `animation_name` (动画名称的字符串名)。

* **`MapData` (地图数据资源) [新增]:**
    * **类型:** Godot `Resource` (`.tres` 文件)。
    * **职责:** 定义一个关卡地图的元数据和配置。
    * **核心字段:** `map_name` (字符串，用于UI显示), `map_scene` (一个指向地图场景文件的 `PackedScene`), `player_spawn_points` (一个 `Vector2` 坐标的数组)。

#### **3. 技术选型与理由 (Technology Selection & Rationale)**

| 技术类别 | 选型 | 理由 (Why) |
| :--- | :--- | :--- |
| **游戏引擎** | **Godot 4.5** | **用户指定。** 提供了成熟的 2D/3D 环境和强大的节点/场景系统。 |
| **核心语言** | **GDScript** | **高开发效率。** 与 Godot 引擎无缝集成，语法简洁，是快速原型开发的最佳选择。 |
| **网络层** | **Godot High-Level Multiplayer API** | **完美匹配需求。** 内置的 RPC 和 `MultiplayerSpawner` 节点能轻松实现监听服务器模型下的状态同步。 |
| **数据格式** | **Godot Resources (`.tres`)** | **策划驱动开发。** 将游戏数据与代码解耦，允许非程序员在编辑器中直接调整游戏平衡。 |
| **地图设计** | **Godot TileMap** | **[新增]** **引擎原生集成。** 提供强大的2D关卡编辑器，用于高效绘制关卡布局、设置碰撞体和导航区域。|
| **版本控制** | **Git** | **行业标准。** 提供强大的分支管理和协作能力。 |

#### **4. 逻辑模块划分 (Logical Module Breakdown)**

* **`NetworkManager`:** (全局单例) 只负责底层网络连接，通过信号与上层逻辑通信。

* **`LobbyManager`:** (全局单例) **[职责更新]** 负责比赛开始前的所有逻辑，包括同步所有玩家的**角色选择**和**地图选择**，以及准备状态。

* **`GameManager`:** (场景节点) **[职责更新]** 负责单局比赛的游戏逻辑。根据 `LobbyManager` 传递的 `MapData` 加载对应的 `TileMap` 场景，并使用 `MapData` 中定义的出生点来生成所有玩家的 `CharacterBody` 实例。

* **`CombatSystem`:** (普通节点) 负责所有战斗逻辑的权威计算。

* **`DataRegistry`:** (全局单例) 负责在启动时加载所有数据资源 (`CharacterData`, `SkillData`, `MapData`)，并提供全局查询接口。

* **`CharacterBody`:** (场景) 代表玩家实体。根据 `is_multiplayer_authority()` 的结果，决定是从 `InputManager` 获取输入意图并发送RPC，还是完全依赖网络数据来更新状态。

* **`InputManager`:** (全局单例) **只服务于本地玩家**，将硬件输入转换为标准化的“输入意图”。

* **`UIManager`:** (全局单例) 负责所有UI元素的显示和交互。

#### **4.1 支柱架构：分层状态机 (HSM) 概念定义**

* **`State` (状态基类):**
    * **概念:** 这是一个行为的原子单元，代表角色在某个瞬间“正在做什么”（如站立、跑步、跳跃）。
    * **核心接口:** 定义了所有具体状态都必须实现的标准方法，包括：
        * `enter()`: 在进入该状态时被调用一次，用于初始化操作（如播放动画）。
        * `exit()`: 在离开该状态时被调用一次，用于清理操作。
        * `process_input()`: 用于处理输入事件，可以根据输入决定是否切换到新状态。
        * `process_physics()`: 在每个物理帧被调用，用于执行该状态下的核心逻辑（如施加力、移动）。

* **`StateMachine` (状态机基类):**
    * **概念:** 这是一个状态的管理者。它持有对所有可能状态的引用，并确保在任何时候只有一个状态是激活的。
    * **核心职责:**
        * 在 `_ready` 函数中完成初始化，并进入初始状态。
        * 在 `_physics_process` 和 `_input` 函数中，调用当前激活状态的相应处理方法。
        * 提供一个 `change_state()` 方法，用于安全地从当前状态过渡到下一个状态（即调用旧状态的 `exit()` 和新状态的 `enter()`）。

### **第二部分：迭代开发蓝图 (Iterative Development Blueprint)**

#### **1. 开发顺序与依赖关系 (Development Order & Dependencies)**

1.  **[基石] `DataRegistry` & 核心数据模型:** 定义并创建 `CharacterData`, `SkillData`, `MapData` 的 `.gd` 脚本和一些测试用的 `.tres` 资源文件。
2.  **`CharacterBody` (单机版) & 测试地图:** 使用 `TileMap` 编辑器创建一个简单的测试关卡。在此关卡中，实现一个功能完备、手感流畅的单机角色，包含完整的状态机逻辑。
3.  **`NetworkManager`:** 实现基础的局域网连接、断开功能和信号。
4.  **`LobbyManager` & 角色/地图选择同步:** 实现大厅逻辑，让玩家可以加入、选择角色和地图，并能看到对方的选择。
5.  **`GameManager` & 网络同步:** 建立客户端发送输入、服务器同步状态的核心循环，并实现从大厅到 `TileMap` 战场的正确加载和角色生成。
6.  **`CombatSystem` & 技能执行:** 实现技能的请求、执行和效果同步。
7.  **`UIManager`:** 构建完整的UI流程（大厅、HUD、结算）。
8.  **核心游戏模式实现:** 在 `GameManager` 中加入胜负逻辑。

---
### **附录 (Appendix)**

#### **集成、部署与运维 (Integration, Deployment & Operations)**

* **最终集成策略:** 核心是频繁的局域网联机测试，覆盖从大厅到结算的完整流程。
* **部署与运维建议:**
    * **CI/CD:** 推荐使用 GitHub Actions，在代码推送到 `main` 分支时，自动为各平台构建可执行文件并打包。
    * **日志记录:** 开发版本中详细记录 RPC 调用、状态切换等信息，并通过全局开关在发布版中禁用，以保证性能。
